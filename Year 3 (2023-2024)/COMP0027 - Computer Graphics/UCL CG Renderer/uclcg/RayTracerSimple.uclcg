// filename: cw1_student.uclcg
// tabGroup: Coursework
// thumbnail: cw1_thumb.png
// displayname: Coursework 1 - 2023/2024
// shortDescription: Coursework 1 - Ray Tracing
// author: None
// isHidden: false
function setup()
{
	UI = {};
	UI.tabs = [];
	UI.titleLong = 'Ray Tracer';
	UI.titleShort = 'RayTracerSimple';
	UI.numFrames = 100000;
	UI.maxFPS = 24;
	UI.renderWidth = 1600;
	UI.renderHeight = 800;

	UI.tabs.push(
		{
		visible: true,
		type: `x-shader/x-fragment`,
		title: `RaytracingDemoFS - GL`,
		id: `RaytracingDemoFS`,
		initialValue: ` 
#define SOLUTION_CYLINDER_AND_PLANE
#define SOLUTION_SHADOW
#define SOLUTION_REFLECTION_REFRACTION
#define SOLUTION_FRESNEL

#define SOLUTION_POLYTOPE

precision highp float;
uniform ivec2 viewport; 

struct PointLight {
	vec3 position;
	vec3 color;
};

struct Material {
	vec3  diffuse;
	vec3  specular;
	float glossiness;
	float reflection;
	float refraction;
	float ior;
};

struct Sphere {
	vec3 position;
	float radius;
	Material material;
};

struct Plane {
	vec3 normal;
	float d;
	Material material;
};

struct Cylinder {
	vec3 position;
	vec3 direction;  
	float radius;
	Material material;
};


const int polytope_size = 10;
struct Polytope {
	vec3 normals[polytope_size];
	float ds[polytope_size];
	Material material;
};


const int lightCount = 2;
const int sphereCount = 3;
const int planeCount = 1;
const int cylinderCount = 2;
const int booleanCount = 2; 

struct Scene {
	vec3 ambient;
	PointLight[lightCount] lights;
	Sphere[sphereCount] spheres;
	Plane[planeCount] planes;
	Cylinder[cylinderCount] cylinders;
	Polytope polytope; 
};

struct Ray {
	vec3 origin;
	vec3 direction;
};

// Contains all information pertaining to a ray/object intersection
struct HitInfo {
	bool hit;
	float t;
	vec3 position;
	vec3 normal;
	Material material;
	bool enteringPrimitive;
};

HitInfo getEmptyHit() {
	return HitInfo(
		false, 
		0.0, 
		vec3(0.0), 
		vec3(0.0), 
		Material(vec3(0.0), vec3(0.0), 0.0, 0.0, 0.0, 0.0),
		false);
}

// Sorts the two t values such that t1 is smaller than t2
void sortT(inout float t1, inout float t2) {
	// Make t1 the smaller t
	if(t2 < t1)  {
		float temp = t1;
		t1 = t2;
		t2 = temp;
	}
}

// Tests if t is in an interval
bool isTInInterval(const float t, const float tMin, const float tMax) {
	return t > tMin && t < tMax;
}

// Get the smallest t in an interval.
bool getSmallestTInInterval(float t0, float t1, const float tMin, const float tMax, inout float smallestTInInterval) {
  
	sortT(t0, t1);

	// As t0 is smaller, test this first
	if(isTInInterval(t0, tMin, tMax)) {
		smallestTInInterval = t0;
		return true;
	}

	// If t0 was not in the interval, still t1 could be
	if(isTInInterval(t1, tMin, tMax)) {
		smallestTInInterval = t1;
		return true;
	}  

	// None was
	return false;
}

HitInfo intersectSphere(const Ray ray, const Sphere sphere, const float tMin, const float tMax) {
              
    vec3 to_sphere = ray.origin - sphere.position;
  
    float a = dot(ray.direction, ray.direction);
    float b = 2.0 * dot(ray.direction, to_sphere);
    float c = dot(to_sphere, to_sphere) - sphere.radius * sphere.radius;
    float D = b * b - 4.0 * a * c;
    if (D > 0.0)
    {
		float t0 = (-b - sqrt(D)) / (2.0 * a);
		float t1 = (-b + sqrt(D)) / (2.0 * a);
      
      	float smallestTInInterval;
      	if(!getSmallestTInInterval(t0, t1, tMin, tMax, smallestTInInterval)) {
          return getEmptyHit();
        }
      
      	vec3 hitPosition = ray.origin + smallestTInInterval * ray.direction;      
		
		//Checking if we're inside the sphere by checking if the ray's origin is inside. If we are, then the normal 
		//at the intersection surface points towards the center. Otherwise, if we are outside the sphere, then the normal 
		//at the intersection surface points outwards from the sphere's center. This is important for refraction.
      	vec3 normal = 
          	length(ray.origin - sphere.position) < sphere.radius + 0.001? 
          	-normalize(hitPosition - sphere.position): 
      		normalize(hitPosition - sphere.position);      
		
		//Checking if we're inside the sphere by checking if the ray's origin is inside,
		// but this time for IOR bookkeeping. 
		//If we are inside, set a flag to say we're leaving. If we are outside, set the flag to say we're entering.
		//This is also important for refraction.
		bool enteringPrimitive = 
          	length(ray.origin - sphere.position) < sphere.radius + 0.001 ? 
          	false:
		    true; 

        return HitInfo(
          	true,
          	smallestTInInterval,
          	hitPosition,
          	normal,
          	sphere.material,
			enteringPrimitive);
    }
    return getEmptyHit();
}

HitInfo intersectPlane(const Ray ray,const Plane plane, const float tMin, const float tMax) {
#ifdef SOLUTION_CYLINDER_AND_PLANE
	// numerator and denominator after plugging in ray equation into normal-distance plane equation and solving for t
	float num = plane.d - dot(plane.normal, ray.origin);
	float denom = dot(plane.normal, ray.direction);
	
	// edge case when ray is parallel to plane
	if (denom == 0.0) {
		return getEmptyHit();
	}
	
    float t = num / denom;
    
    if (t < tMin || t > tMax) {
        return getEmptyHit();
    }
	
	// angle between ray and normal is more than 90 degrees, which means it has to be entering the plane
	bool enteringPrimitive = denom < 0.0;
		
	// if ray is exiting, we want to invert the normal, important for refraction
	vec3 normal = enteringPrimitive ? plane.normal : -plane.normal;
	    
    return HitInfo(
        true,
        t,
        ray.origin + t * ray.direction,
        normal,
        plane.material,
        enteringPrimitive
    );
	
#endif  
		return getEmptyHit();
}

float lengthSquared(vec3 x) {
	return dot(x, x);
}

HitInfo intersectCylinder(const Ray ray, const Cylinder cylinder, const float tMin, const float tMax) {
#ifdef SOLUTION_CYLINDER_AND_PLANE
	// derived from point-line distance equation from https://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html by plugging in ray equation for x0
	// idea is to find closest t where distance between ray point and cylinder is same as the radius of the cylinder
	
	// two points on axis of cylinder
	vec3 x1 = cylinder.position;
	vec3 x2 = cylinder.position + cylinder.direction;
	
	// constant term after expanding cross product in numerator of point-line distance equation
	vec3 y = cross(ray.origin, (x1 - x2)) + cross(x1, x2);
	
	// coefficient of t after expanding cross product in numerator of equation
	vec3 z = cross(ray.direction, (x1 - x2));
	
	// quadratic coefficients of t after turning norm of numerator into dot product and rearranging
	float a = dot(z, z);
	float b = 2.0 * dot(y, z);
	float c1 = cylinder.radius * length(x2 - x1);
	float c = dot(y, y) - c1 * c1; 
	
    float discriminant = b * b - 4.0 * a * c;
    
	// standard quadratic solving
    if (discriminant > 0.0) {
        float t0 = (-b - sqrt(discriminant)) / (2.0 * a);
        float t1 = (-b + sqrt(discriminant)) / (2.0 * a);
        
        float smallestTInInterval;
        if (!getSmallestTInInterval(t0, t1, tMin, tMax, smallestTInInterval)) {
            return getEmptyHit();
        }
        
        vec3 hitPosition = ray.origin + smallestTInInterval * ray.direction;
		
		// to find the normal we first try to the find the closest point on the cylinder axis to the hitPosition. The normalized vector between these two points will be the normal
		// due to the shortest distance between a line and a point being perpendicular.
        vec3 normal = normalize(hitPosition - (cylinder.position + cylinder.direction * dot(hitPosition - cylinder.position, normalize(cylinder.direction))));
		
		bool enteringPrimitive = dot(ray.direction, normal) < 0.0;
		
		// if ray is exiting, we want to invert the normal, important for refraction
		normal = enteringPrimitive ? normal : -normal;
        
        return HitInfo(
            true,
            smallestTInInterval,
            hitPosition,
            normal,
            cylinder.material,
            enteringPrimitive
        );
    
    return getEmptyHit();
}

#endif  
    return getEmptyHit();
}

bool inside(const vec3 position, const Sphere sphere) {
	return length(position - sphere.position) < sphere.radius;
}

HitInfo intersectPolytope(const Ray ray, const Polytope polytope, const float tMin, const float tMax) {
	
#ifdef SOLUTION_POLYTOPE
	// basic idea is from this paper: https://www.sciencedirect.com/science/article/pii/B9780080507545500530
	// we find highest t-value where the ray is entering the polytope and the lowest t-value where the ray is exiting the polytope. 
	// If the max entry t-value is less than the min exit t-value, then an intersection is possible otherwise it is not
	
	vec3 entryNormal, exitNormal;
	float tEnter, tExit;
	
	// arbitrary out of bounds initial values in order to fail tMin-tMax range check at the very end
	tExit = tMax + 1.0;
	tEnter = -tExit;
	
	for (int i = 0; i < polytope_size; i++) {
		// break out of loop if we exceed number of defined faces
		if (polytope.normals[i] == vec3(0.0)) {
			break;
		}
		
		float num = (polytope.ds[i] - dot(polytope.normals[i], ray.origin));
		float denom = dot(ray.direction, polytope.normals[i]);
		
		if (denom == 0.0) {
			continue;
		}
		
		// standard ray plane intersection
		float t = num / denom;
		
		// ray is entering plane from outside of polytope and we have found an entry point that is further away from the origin
		if (denom < 0.0 && t > tEnter) {
			entryNormal = polytope.normals[i];
			tEnter = t;
		}
		// ray is exiting plane from inside of polytope and we have found an exit that is closer to the origin
		if (denom > 0.0 && t < tExit) {
			exitNormal = polytope.normals[i];
			tExit = t;
		}		
	}
	
	vec3 normal;
	float tResult;
	bool enteringPrimitive;
	
	// the entry point is in front of the ray's origin, so we can use that as the closest intersection
	if (tEnter >= 0.0) {
		normal = entryNormal;
		tResult = tEnter;
		enteringPrimitive = true;
	}
	// the entry point is behind the ray's origin, which means our closest intersection has to be the exit point.
	else {
		// invert the normal if exiting since otherwise it would be the outward facing normal of the plane
		normal = -exitNormal;
		tResult = tExit;
		enteringPrimitive = false;
	}
	
	// test out of bounds, or if our exit point is closer to the origin than the entry point
	if (tResult < tMin || tResult > tMax || tExit < tEnter) {
		return getEmptyHit();
	}
	
	return HitInfo(
        true,
        tResult,
        ray.origin + tResult * ray.direction,
        normal,
        polytope.material,
        enteringPrimitive
    );
	
	
#else
	// Put your Polytope intersection code in the #ifdef above!
#endif
	return getEmptyHit();
}

uniform float time;

HitInfo getBetterHitInfo(const HitInfo oldHitInfo, const HitInfo newHitInfo) {
	if(newHitInfo.hit)
  		if(newHitInfo.t < oldHitInfo.t)  // No need to test for the interval, this has to be done per-primitive
          return newHitInfo;
  	return oldHitInfo;
}

HitInfo intersectScene(const Scene scene, const Ray ray, const float tMin, const float tMax) {
	HitInfo bestHitInfo;
	bestHitInfo.t = tMax;
	bestHitInfo.hit = false;
	
	bestHitInfo = getBetterHitInfo(bestHitInfo, intersectPolytope(ray, scene.polytope, tMin, tMax));

	for (int i = 0; i < planeCount; ++i) {
		bestHitInfo = getBetterHitInfo(bestHitInfo, intersectPlane(ray, scene.planes[i], tMin, tMax));
	}
	for (int i = 0; i < sphereCount; ++i) {
		bestHitInfo = getBetterHitInfo(bestHitInfo, intersectSphere(ray, scene.spheres[i], tMin, tMax));
	}
	for (int i = 0; i < cylinderCount; ++i) {
		bestHitInfo = getBetterHitInfo(bestHitInfo, intersectCylinder(ray, scene.cylinders[i], tMin, tMax));
	}
	
	return bestHitInfo;
}

vec3 shadeFromLight(
  const Scene scene,
  const Ray ray,
  const HitInfo hit_info,
  const PointLight light)
{ 
  vec3 hitToLight = light.position - hit_info.position;
  
  vec3 lightDirection = normalize(hitToLight);
  vec3 viewDirection = normalize(hit_info.position - ray.origin);
  vec3 reflectedDirection = reflect(viewDirection, hit_info.normal);
  float diffuse_term = max(0.0, dot(lightDirection, hit_info.normal));
  float specular_term  = pow(max(0.0, dot(lightDirection, reflectedDirection)), hit_info.material.glossiness);

#ifdef SOLUTION_SHADOW
	float visibility = 1.0;
	
	// construct a ray from hit_position to light source for shadow testing
	Ray toLight;
    toLight.direction = lightDirection;
	
	// small offset to prevent intersection at same hit_point
	toLight.origin = hit_info.position + 0.001 * lightDirection;

    // check if toLight ray intersects with any objects
	HitInfo shadowTest = intersectScene(scene, toLight, 0.001, 10000.0);
	
	// object is in shadow only if there is a intersection in-between the hit_position and the light source
    if (shadowTest.hit && shadowTest.t < length(hitToLight)) {
        visibility =  0.0;
    }

#else
  // Put your shadow test here
  float visibility = 1.0;
#endif
  return 	visibility * 
    		light.color * (
    		specular_term * hit_info.material.specular +
      		diffuse_term * hit_info.material.diffuse);
}

vec3 background(const Ray ray) {
  // A simple implicit sky that can be used for the background
  return vec3(0.2) + vec3(0.8, 0.6, 0.5) * max(0.0, ray.direction.y);
}

// It seems to be a WebGL issue that the third parameter needs to be inout instea dof const on Tobias' machine
vec3 shade(const Scene scene, const Ray ray, inout HitInfo hitInfo) {
	
  	if(!hitInfo.hit) {
  		return background(ray);
  	}
  
    vec3 shading = scene.ambient * hitInfo.material.diffuse;
    for (int i = 0; i < lightCount; ++i) {
        shading += shadeFromLight(scene, ray, hitInfo, scene.lights[i]); 
    }
    return shading;
}


Ray getFragCoordRay(const vec2 frag_coord) {
  	float sensorDistance = 1.0;
  	vec2 sensorMin = vec2(-1, -0.5);
  	vec2 sensorMax = vec2(1, 0.5);
  	vec2 pixelSize = (sensorMax- sensorMin) / vec2(viewport.x, viewport.y);
  	vec3 origin = vec3(0, 0, sensorDistance);
    vec3 direction = normalize(vec3(sensorMin + pixelSize * frag_coord, -sensorDistance));  
  
  	return Ray(origin, direction);
}

float fresnel(const vec3 viewDirection, const vec3 normal, const float sourceIOR, const float destIOR) {
#ifdef SOLUTION_FRESNEL
	// use dot product approximation of fresnel. A higher dot product means a smaller angle, which means more refraction and less reflection
	// and vice versa for a lower dot product
	float fresnelFactor = dot(-viewDirection, normal);
	
	// limit fresnel within range of 0-1 since it is supposed to represent a ratio. Also invert the value by subtracting it by 1 to ensure that higher
	// fresnelFactor corresponds to higher reflection ratio
	fresnelFactor = clamp(1.0 - fresnelFactor, 0.0, 1.0);
	
	// square fresnelFactor to make effect more intense
	return fresnelFactor * fresnelFactor;
#else
  	// Put your code to compute the Fresnel effect in the ifdef above
	return 1.0;
#endif
}

vec3 colorForFragment(const Scene scene, const vec2 fragCoord) {
      
    Ray initialRay = getFragCoordRay(fragCoord);  
  	HitInfo initialHitInfo = intersectScene(scene, initialRay, 0.001, 10000.0);  
  	vec3 result = shade(scene, initialRay, initialHitInfo);
	
  	Ray currentRay;
  	HitInfo currentHitInfo;
  	
  	// Compute the reflection
  	currentRay = initialRay;
  	currentHitInfo = initialHitInfo;
  	
  	// The initial strength of the reflection
  	float reflectionWeight = 1.0;
	
	// The initial medium is air
  	float currentIOR = 1.0;
	
    float sourceIOR = 1.0;
	float destIOR = 1.0;
  	
  	const int maxReflectionStepCount = 2;
  	for(int i = 0; i < maxReflectionStepCount; i++) {
      
      if(!currentHitInfo.hit) break;
      
#ifdef SOLUTION_REFLECTION_REFRACTION
	  reflectionWeight *= currentHitInfo.material.reflection;
#else
      // Put your reflection weighting code in the ifdef above
#endif
      
#ifdef SOLUTION_FRESNEL
	  reflectionWeight *= fresnel(currentRay.direction, currentHitInfo.normal, sourceIOR, destIOR);
#else
      // Replace with Fresnel code in the ifdef above
      reflectionWeight *= 0.5;
#endif
      
      Ray nextRay;
#ifdef SOLUTION_REFLECTION_REFRACTION
	  nextRay.direction = reflect(currentRay.direction, currentHitInfo.normal);
	  
	  // small offset to avoid intersection with this surface on next iteration
	  nextRay.origin = currentHitInfo.position + 0.001 * nextRay.direction;
#else
	// Put your code to compute the reflection ray in the ifdef above
#endif
      currentRay = nextRay;
      
      currentHitInfo = intersectScene(scene, currentRay, 0.001, 10000.0);      
            
      result += reflectionWeight * shade(scene, currentRay, currentHitInfo);
    }
  
  	// Compute the refraction
  	currentRay = initialRay;  
  	currentHitInfo = initialHitInfo;
   
  	// The initial strength of the refraction.
  	float refractionWeight = 1.0;
  
  	const int maxRefractionStepCount = 2;
  	for(int i = 0; i < maxRefractionStepCount; i++) {
      
#ifdef SOLUTION_REFLECTION_REFRACTION
	  refractionWeight *= currentHitInfo.material.refraction;
#else
      // Put your refraction weighting code in the ifdef above
      refractionWeight *= 0.5;
#endif

#ifdef SOLUTION_FRESNEL
	  refractionWeight *= (1.0 - fresnel(currentRay.direction, currentHitInfo.normal, sourceIOR, destIOR));
#else
      // Put your Fresnel code in the ifdef above 
#endif

      Ray nextRay;


#ifdef SOLUTION_REFLECTION_REFRACTION
	  // if we are exiting, we can't use the material ior as the destIOR so we use the background ior
	  destIOR = currentHitInfo.enteringPrimitive ? currentHitInfo.material.ior : currentIOR;
	  
	  float IORratio = sourceIOR / destIOR;
	  
	  nextRay.direction = refract(currentRay.direction, currentHitInfo.normal, IORratio);
		
	  // small offset to avoid intersection with this surface on next iteration
	  nextRay.origin = currentHitInfo.position + 0.001 * nextRay.direction;
	  
	  // set the sourceIOR to the material we just entered
	  sourceIOR = destIOR;
	  currentRay = nextRay;
#else
      float sourceIOR;
	  float destIOR;
	// Put your code to compute the reflection ray and track the IOR in the ifdef above
#endif
      currentHitInfo = intersectScene(scene, currentRay, 0.001, 10000.0);
            
      result += refractionWeight * shade(scene, currentRay, currentHitInfo);
      
      if(!currentHitInfo.hit) break;
    }
  return result;
}

Material getDefaultMaterial() {
  return Material(vec3(0.3), vec3(0), 0.0, 0.0, 0.0, 0.0);
}

Material getPaperMaterial() {
  return Material(vec3(0.7, 0.7, 0.7), vec3(0, 0, 0), 5.0, 0.0, 0.0, 0.0);
}

Material getPlasticMaterial() {
	return Material(vec3(0.9, 0.3, 0.1), vec3(1.0), 10.0, 0.9, 0.0, 0.0);
}

Material getGlassMaterial() {
	return Material(vec3(0.0), vec3(0.0), 5.0, 1.0, 1.0, 1.5);
}

Material getSteelMirrorMaterial() {
	return Material(vec3(0.1), vec3(0.3), 20.0, 0.8, 0.0, 0.0);
}

Material getMetaMaterial() {
	return Material(vec3(0.1, 0.2, 0.5), vec3(0.3, 0.7, 0.9), 20.0, 0.8, 0.0, 0.0);
}

vec3 tonemap(const vec3 radiance) {
  const float monitorGamma = 2.0;
  return pow(radiance, vec3(1.0 / monitorGamma));
}

void clearShape(inout Polytope shape) {
	/*
		clear the polytope
	*/
	for (int i = 0; i < polytope_size; i++) {
		shape.normals[i] = vec3(0.0);
		shape.ds[i] = 0.0;
	}
}
void loadCube(float size, inout Polytope cube) {
	/* 
		load a cube to test intersection code
		
		NOTE THAT:
		Here the cube is loaded in a specific order => (top, bottom, front, back, left, right).
		You should load the diamond in a similar way.
	*/
	cube.normals[0] = vec3(0, 1, 0); // TOP
	cube.normals[1] = vec3(0, -1, 0); // BOTTOM
	cube.normals[2] = vec3(0, 0, 1); // FRONT
	cube.normals[3] = vec3(0, 0, -1); // BACK
	cube.normals[4] = vec3(-1, 0, 0); // LEFT
	cube.normals[5] = vec3(1, 0, 0); // RIGHT
	for (int i = 0; i < 6; i++) {
		cube.ds[i] = size; // the size of the cube
	}
}

void loadDiamond(float height, float width, float slope, inout Polytope diamond, inout bool isSuccessful) {
	/*
		Implement your code to load a diamond at origin (0.0, 0.0, 0.0)
		
		Input Arguments:
			height: the distance between the top plane and the bottom plane
			width: the edge length of the square in the middle of the diamond
			slope: the angle between the 8 side planes and the X-Z plane (in radians)
			
		Inout Arguments:
			diamond: the polytope that you need to modify
			isSuccessful: true if diamond is loaded successfully, false otherwise
		
		NOTE THAT:
		Please load the diamond, i.e., 10 planes, in this order:
		(top, bottom, upper-front, upper-back, upper-left, upper-right, lower-front, lower-back, lower-left, lower-right)
	*/
	
#ifdef SOLUTION_POLYTOPE
	// to get normals of sloped planes, use rotation matrix and rotate top and bottom normals by slope and -slope along the x and z axis respectively. 
	// gives all combinations of rotations needed
	
	// precompute sin and cos of slope to use for rotated normals
	float cos_slope = cos(slope);
	float sin_slope = sin(slope); 
	
	// for non-sloped planes, the distance from origin is just the total height divided by 2
	float straight_ds = height / 2.0;
	
	// for sloped planes, we can draw a right angle triangle from plane to origin and solve for the distance using the slope and width
	float sloped_ds = sin_slope * width / 2.0;
	
	diamond.normals[0] = vec3(0, 1, 0); // top
	diamond.ds[0] = straight_ds;
	
	diamond.normals[1] = vec3(0, -1, 0); // bottom
	diamond.ds[1] = straight_ds;
	
	diamond.normals[2] = vec3(0, cos_slope, sin_slope); // upper-front
	diamond.ds[2] = sloped_ds;
	
	diamond.normals[3] = vec3(0, cos_slope, -sin_slope); // upper-back
	diamond.ds[3] = sloped_ds;
	
	diamond.normals[4] = vec3(-sin_slope, cos_slope, 0); // upper-left
	diamond.ds[4] = sloped_ds;
	
	diamond.normals[5] = vec3(sin_slope, cos_slope, 0); // upper-right
	diamond.ds[5] = sloped_ds;
	
	diamond.normals[6] = vec3(0, -cos_slope, sin_slope); // lower-front
	diamond.ds[6] = sloped_ds;

	diamond.normals[7] = vec3(0, -cos_slope, -sin_slope); // lower-back
	diamond.ds[7] = sloped_ds;
	
	diamond.normals[8] = vec3(-sin_slope, -cos_slope, 0); // lower-left
	diamond.ds[8] = sloped_ds;
	
	diamond.normals[9] = vec3(sin_slope, -cos_slope, 0); // lower-right
	diamond.ds[9] = sloped_ds;
	
	isSuccessful = true;		
#else
	// Put your code in the above solution block
	// don't forget to set it true in your implementation!
	isSuccessful = false;
#endif
}

void main() {
	// Setup scene
	Scene scene;
	scene.ambient = vec3(0.12, 0.15, 0.2);
	scene.lights[0].position = vec3(5, 15, -5);
	scene.lights[0].color    = 0.5 * vec3(0.9, 0.5, 0.1);

	scene.lights[1].position = vec3(-15, 5, 2);
	scene.lights[1].color    = 0.5 * vec3(0.1, 0.3, 1.0);
	
	// Primitives
	bool specialScene = false;
	
#if defined(SOLUTION_POLYTOPE)
	specialScene = true;
#endif
	
	if (specialScene) {
		// Polytope diamond scene
		float slope = radians(70.0);
		bool isDiamond = false;
		loadDiamond(8.0, 4.37, slope, scene.polytope, isDiamond);
		
		if (!isDiamond) {
			clearShape(scene.polytope);
			loadCube(3.0, scene.polytope);
		}
		
		// rotate the diamond along the Y axis
		mat3 rot;
		float speed = 10.0;
		float theta = radians(speed * time);
		
		// Three angles that might be tested for marking
		// theta = radians(0.0);
		// theta = radians(30.0);
		// theta = radians(45.0);
		
		// rotating
		rot[0] = vec3(cos(theta), 0, -sin(theta));
		rot[1] = vec3(0, 1, 0);
		rot[2] = vec3(sin(theta), 0, cos(theta));
		for (int i = 0; i < polytope_size; i++) {
			scene.polytope.normals[i] = rot * scene.polytope.normals[i];
		}
		
		// push the origin-centered diamond along the Z axis to display it properly
		float at_z = 15.0;
		// push the upper part
		scene.polytope.ds[2] = scene.polytope.ds[2] - cos(theta) * sin(slope) * at_z;
		scene.polytope.ds[3] = scene.polytope.ds[3] + cos(theta) * sin(slope) * at_z;
		scene.polytope.ds[4] = scene.polytope.ds[4] - sin(theta) * sin(slope) * at_z;
		scene.polytope.ds[5] = scene.polytope.ds[5] + sin(theta) * sin(slope) * at_z;
		if (isDiamond) {
			// push the lower part
			scene.polytope.ds[6] = scene.polytope.ds[6] - cos(theta) * sin(slope) * at_z;
			scene.polytope.ds[7] = scene.polytope.ds[7] + cos(theta) * sin(slope) * at_z;
			scene.polytope.ds[8] = scene.polytope.ds[8] - sin(theta) * sin(slope) * at_z;
			scene.polytope.ds[9] = scene.polytope.ds[9] + sin(theta) * sin(slope) * at_z;
		}
		
		if (isDiamond) scene.polytope.material = getGlassMaterial();
		else scene.polytope.material = getMetaMaterial();
		
		// add floor
		scene.planes[0].normal            		= normalize(vec3(0, 1.0, 0));
		scene.planes[0].d              			= -4.5;
		scene.planes[0].material				= getSteelMirrorMaterial();
		if (isDiamond) {
			// add some primitives to play around
			scene.cylinders[0].position            	= vec3(-15, 1, -26);
			scene.cylinders[0].direction            = normalize(vec3(-2, 2, -1));
			scene.cylinders[0].radius         		= 1.5;
			scene.cylinders[0].material				= getPaperMaterial();

			scene.cylinders[1].position            	= vec3(15, 1, -26);
			scene.cylinders[1].direction            = normalize(vec3(2, 2, -1));
			scene.cylinders[1].radius         		= 1.5;
			scene.cylinders[1].material				= getPlasticMaterial();
		}
	}
	else {
		// normal scene
		scene.spheres[0].position            	= vec3(10, -5, -16);
		scene.spheres[0].radius              	= 6.0;
		scene.spheres[0].material 				= getPaperMaterial();

		scene.spheres[1].position            	= vec3(-7, -2, -13);
		scene.spheres[1].radius             	= 4.0;
		scene.spheres[1].material				= getPlasticMaterial();

		scene.spheres[2].position            	= vec3(0, 0.5, -5);
		scene.spheres[2].radius              	= 2.0;
		scene.spheres[2].material   			= getGlassMaterial();

		scene.planes[0].normal            		= normalize(vec3(0, 1.0, 0));
		scene.planes[0].d              			= -4.5;
		scene.planes[0].material				= getSteelMirrorMaterial();

		scene.cylinders[0].position            	= vec3(-1, 1, -26);
		scene.cylinders[0].direction            = normalize(vec3(-2, 2, -1));
		scene.cylinders[0].radius         		= 1.5;
		scene.cylinders[0].material				= getPaperMaterial();

		scene.cylinders[1].position            	= vec3(4, 1, -5);
		scene.cylinders[1].direction            = normalize(vec3(1, 4, 1));
		scene.cylinders[1].radius         		= 0.4;
		scene.cylinders[1].material				= getPlasticMaterial();
	}

	// Compute color for fragment
	gl_FragColor.rgb = tonemap(colorForFragment(scene, gl_FragCoord.xy));
	gl_FragColor.a = 1.0;

}
`,
		description: ``,
		wrapFunctionStart: ``,
		wrapFunctionEnd: ``
	});

	UI.tabs.push(
		{
		visible: false,
		type: `x-shader/x-vertex`,
		title: `RaytracingDemoVS - GL`,
		id: `RaytracingDemoVS`,
		initialValue: `attribute vec3 position;
    uniform mat4 modelViewMatrix;
    uniform mat4 projectionMatrix;
  
    void main(void) {
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
`,
		description: ``,
		wrapFunctionStart: ``,
		wrapFunctionEnd: ``
	});

	 return UI; 
}//!setup

var gl;
function initGL(canvas) {
	try {
		gl = canvas.getContext("experimental-webgl");
		gl.viewportWidth = canvas.width;
		gl.viewportHeight = canvas.height;
	} catch (e) {
	}
	if (!gl) {
		alert("Could not initialise WebGL, sorry :-(");
	}
}

function getShader(gl, id) {
	var shaderScript = document.getElementById(id);
	if (!shaderScript) {
		return null;
	}

	var str = "";
	var k = shaderScript.firstChild;
	while (k) {
		if (k.nodeType == 3) {
			str += k.textContent;
		}
		k = k.nextSibling;
	}

	var shader;
	if (shaderScript.type == "x-shader/x-fragment") {
		shader = gl.createShader(gl.FRAGMENT_SHADER);
	} else if (shaderScript.type == "x-shader/x-vertex") {
		shader = gl.createShader(gl.VERTEX_SHADER);
	} else {
		return null;
	}

    console.log(str);
	gl.shaderSource(shader, str);
	gl.compileShader(shader);

	if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
		alert(gl.getShaderInfoLog(shader));
		return null;
	}

	return shader;
}

function RaytracingDemo() {
}

RaytracingDemo.prototype.initShaders = function() {

	this.shaderProgram = gl.createProgram();

	gl.attachShader(this.shaderProgram, getShader(gl, "RaytracingDemoVS"));
	gl.attachShader(this.shaderProgram, getShader(gl, "RaytracingDemoFS"));
	gl.linkProgram(this.shaderProgram);

	if (!gl.getProgramParameter(this.shaderProgram, gl.LINK_STATUS)) {
		alert("Could not initialise shaders");
	}

	gl.useProgram(this.shaderProgram);

	this.shaderProgram.vertexPositionAttribute = gl.getAttribLocation(this.shaderProgram, "position");
	gl.enableVertexAttribArray(this.shaderProgram.vertexPositionAttribute);

	this.shaderProgram.projectionMatrixUniform = gl.getUniformLocation(this.shaderProgram, "projectionMatrix");
	this.shaderProgram.modelviewMatrixUniform = gl.getUniformLocation(this.shaderProgram, "modelViewMatrix");
}

RaytracingDemo.prototype.initBuffers = function() {
	this.triangleVertexPositionBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, this.triangleVertexPositionBuffer);
	
	var vertices = [
		 -1,  -1,  0,
		 -1,  1,  0,
		 1,  1,  0,

		 -1,  -1,  0,
		 1,  -1,  0,
		 1,  1,  0,
	 ];
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
	this.triangleVertexPositionBuffer.itemSize = 3;
	this.triangleVertexPositionBuffer.numItems = 3 * 2;
}

function getTime() {  
	var d = new Date();
	return d.getMinutes() * 60.0 + d.getSeconds() + d.getMilliseconds() / 1000.0;
}

RaytracingDemo.prototype.drawScene = function() {
			
	var perspectiveMatrix = new J3DIMatrix4();	
	perspectiveMatrix.setUniform(gl, this.shaderProgram.projectionMatrixUniform, false);

	var modelViewMatrix = new J3DIMatrix4();	
	modelViewMatrix.setUniform(gl, this.shaderProgram.modelviewMatrixUniform, false);

	gl.uniform1f(gl.getUniformLocation(this.shaderProgram, "time"), getTime());
	
	gl.bindBuffer(gl.ARRAY_BUFFER, this.triangleVertexPositionBuffer);
	gl.vertexAttribPointer(this.shaderProgram.vertexPositionAttribute, this.triangleVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
	
	gl.uniform2iv(gl.getUniformLocation(this.shaderProgram, "viewport"), [getRenderTargetWidth(), getRenderTargetHeight()]);

	gl.drawArrays(gl.TRIANGLES, 0, this.triangleVertexPositionBuffer.numItems);
}

RaytracingDemo.prototype.run = function() {
	this.initShaders();
	this.initBuffers();

	gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
	gl.clear(gl.COLOR_BUFFER_BIT);

	this.drawScene();
};

function init() {	
	

	env = new RaytracingDemo();	
	env.run();

    return env;
}

function compute(canvas)
{
    env.initShaders();
    env.initBuffers();

    gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
    gl.clear(gl.COLOR_BUFFER_BIT);

    env.drawScene();
}
